#reader(lib"read.ss""wxme")WXME0108 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 6.7 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 32 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 29 #"drscheme:bindings-snipclass%\0"
1 0 101
(
 #"((lib \"ellipsis-snip.rkt\" \"drracket\" \"private\") (lib \"ellipsi"
 #"s-snip-wxme.rkt\" \"drracket\" \"private\"))\0"
) 2 0 88
(
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 34 #"(lib \"bullet-snip.rkt\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 29 #"drclickable-string-snipclass\0"
0 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 55 0 1 #"\0"
0 75 1 #"\0"
0 12 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 6 #"Menlo\0"
0 12 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 255 -1 -1 2
1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1 0 -1 -1 93 -1 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 35
#"framework:syntax-color:scheme:text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 49
#"framework:syntax-color:scheme:hash-colon-keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 37 #"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1           0 4156 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o1"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/1.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o3"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/3.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o4"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/4.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o7"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/7.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o8"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/8.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"o9"
0 0 24 3 1 #" "
0 0 19 3 16 #"\"original/9.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o10"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/10.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o11"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/11.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o15"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/15.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o16"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/16.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o18"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/18.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"o22"
0 0 24 3 1 #" "
0 0 19 3 17 #"\"original/22.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"t1-1"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/typist1/1.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"t1-2"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/typist1/2.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"t1-8"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/typist1/8.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t1-14"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist1/14.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t1-16"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist1/16.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t1-17"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist1/17.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"t2-4"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/typist2/4.txt\""
0 0 24 3 2 #") "
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"t2-9"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/typist2/9.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t2-12"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist2/12.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t2-13"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist2/13.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t2-18"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist2/18.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"t2-19"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/typist2/19.txt\""
0 0 24 3 2 #") "
0 0 17 3 13 #"; no original"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"u3"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/unknown/3.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"u5"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/unknown/5.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"u6"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/unknown/6.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"u7"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"corrupted/unknown/7.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u10"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/10.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u11"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/11.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u15"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/15.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u20"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/20.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u21"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/21.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u22"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/22.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u23"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/23.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"u24"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"corrupted/unknown/24.txt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; File"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";;   hmm.scm"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 9 #";; Author"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   Jerod Weinman - Noyce 3825"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Summary"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;   Provides support routines for a simple first-order language mar"
 #"kov model"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Provides"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;   (count-transitions! filename counts)"
0 0 24 29 1 #"\n"
0 0 17 3 29 #";;   (marginal-counts counts)"
0 0 24 29 1 #"\n"
0 0 17 3 45 #";;   (normalize-marginal-counts! counts-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   (evidence-exact corrupt-filename typo-cond lang-cond lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 66
#";;   (log-evidence corrupt-filename typo-cond lang-cond lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";;   (most-likely-sequence corrupt-filename  typo-cond lang-cond lan"
 #"g-marg)"
) 0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   (count-errors-file correct-filename other-filename)"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;   (count-errors-list correct-filename char-list)"
0 0 24 29 1 #"\n"
0 0 17 3 40 #";;   (list->file char-list out-filename)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Depends"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";;   Some procedures (i.e., vector-map!) from charmodel.scm are need"
 #"ed; "
) 0 0 24 29 1 #"\n"
0 0 17 3 50 #";;     execute (load \"charmodel.scm\") prior to use"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 9 #";;   iota"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 42 #";;   Create a list of the first N integers"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";;   n, an integer"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   lst, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";;   n >= 0"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;  (= index (list-ref lst index)) for 0 <= index < n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;   Inspired by a routine of the same name in the Grinnell CSC-151 "
 #"curriculum"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"iota"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"when"
0 0 24 3 2 #" ("
0 0 14 3 3 #"not"
0 0 24 3 2 #" ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 8 #"integer?"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 3 #") ("
0 0 14 3 2 #">="
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 58
#"\"expected non-negative integer as first parameter, given \""
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (("
0 0 14 3 11 #"list-so-far"
0 0 24 3 1 #" "
0 0 14 3 4 #"null"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 16 #"               ("
0 0 14 3 1 #"i"
0 0 24 3 2 #" ("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 1 #"<"
0 0 24 3 1 #" "
0 0 14 3 1 #"i"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 14 3 11 #"list-so-far"
0 0 24 29 1 #"\n"
0 0 24 3 11 #"          ("
0 0 14 3 4 #"loop"
0 0 24 3 2 #" ("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 14 3 1 #"i"
0 0 24 3 1 #" "
0 0 14 3 11 #"list-so-far"
0 0 24 3 3 #") ("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"i"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 6 #"))))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 14 #";;   make-list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 42 #";;   Create a list of  N copies of a value"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";;   n, an integer"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   val, a value"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   lst, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";;   n >= 0"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;  (= val (list-ref lst index)) for 0 <= index < n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;   Inspired by a routine of the same name in the Grinnell CSC-151 "
 #"curriculum"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 9 #"make-list"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 14 3 3 #"val"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"when"
0 0 24 3 2 #" ("
0 0 14 3 3 #"not"
0 0 24 3 2 #" ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 8 #"integer?"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 3 #") ("
0 0 14 3 2 #">="
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 58
#"\"expected non-negative integer as first parameter, given \""
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (("
0 0 14 3 11 #"list-so-far"
0 0 24 3 1 #" "
0 0 14 3 4 #"null"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 16 #"               ("
0 0 14 3 1 #"i"
0 0 24 3 2 #" ("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 1 #"<"
0 0 24 3 1 #" "
0 0 14 3 1 #"i"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 14 3 11 #"list-so-far"
0 0 24 29 1 #"\n"
0 0 24 3 11 #"          ("
0 0 14 3 4 #"loop"
0 0 24 3 2 #" ("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 14 3 3 #"val"
0 0 24 3 1 #" "
0 0 14 3 11 #"list-so-far"
0 0 24 3 3 #") ("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"i"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 6 #"))))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   left-section"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";;   Transform a binary to a unary procedure by fixing the left oper"
 #"and"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 20 #";;   op, a procedure"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";;   left, a value"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;   unary, a procedure"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 29 #";;   op is a binary procedure"
0 0 24 29 1 #"\n"
0 0 17 3 44 #";;   left is a valid (first) parameter to op"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";;   unary takes one parameter so that "
0 0 24 29 1 #"\n"
0 0 17 3 40 #";;     (unary right)  == (op left right)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;   Inspired by a routine of the same name in the Grinnell CSC-151 "
 #"curriculum"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 12 #"left-section"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"op"
0 0 24 3 1 #" "
0 0 14 3 4 #"left"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 5 #"right"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 2 #"op"
0 0 24 3 1 #" "
0 0 14 3 4 #"left"
0 0 24 3 1 #" "
0 0 14 3 5 #"right"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"l-s"
0 0 24 3 1 #" "
0 0 14 3 12 #"left-section"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";;   arg+max"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";;   Find the index of and value of the largest number in a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   vals, a list"
0 0 24 29 1 #"\n"
0 0 17 3 5 #";;   "
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";;   result, a pair"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   vals is non-empty: (> 0 (length vals))"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   Every element of vals is a number: (number? (list-ref vals i)) "
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;      for 0 <= i < (length vals)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";;   (car pair) is a number"
0 0 24 29 1 #"\n"
0 0 17 3 62
#";;   (car pair) is a member of vals: (member? vals (car pair))"
0 0 24 29 1 #"\n"
0 0 17 3 46 #";;   (car pair) is a largest element of vals: "
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;     (>= (car pair) (list-ref vals i)) for 0 <= i < (length vals)"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   (cdr pair) is an index of (car pair): "
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;      (= (car pair) (list-ref vals (cdr pair)))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 7 #"arg+max"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 4 #"vals"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (["
0 0 14 3 6 #"argmax"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ["
0 0 14 3 6 #"maxval"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 4 #"vals"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ["
0 0 14 3 7 #"current"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ["
0 0 14 3 9 #"remaining"
0 0 24 3 2 #" ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 4 #"vals"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 9 #"remaining"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 14 3 6 #"maxval"
0 0 24 3 1 #" "
0 0 14 3 6 #"argmax"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 1 #">"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 9 #"remaining"
0 0 24 3 2 #") "
0 0 14 3 6 #"maxval"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 4 #"loop"
0 0 24 3 1 #" "
0 0 14 3 7 #"current"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 9 #"remaining"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 14 3 7 #"current"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 9 #"remaining"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 4 #"loop"
0 0 24 3 1 #" "
0 0 14 3 6 #"argmax"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"      "
0 0 14 3 6 #"maxval"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 14 3 7 #"current"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 9 #"remaining"
0 0 24 3 7 #"))]))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";;   argmax"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;   Find the index of the largest number in a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   vals, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   index, an integer"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   vals is non-empty: (< 0 (length vals))"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   Every element of vals is a number: (number? (list-ref vals i)) "
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;      for 0 <= i < (length vals)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   0 <= index < (length vals)"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   The value at index is a largest element of the list"
0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;     (>= (list-ref vals index) (list-ref vals i)) for 0 <= i < (le"
 #"ngth vals)"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"argmax"
0 0 24 3 2 #" ("
0 0 14 3 7 #"compose"
0 0 24 3 1 #" "
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 7 #"arg+max"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   index->char"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 79
(
 #";;    Convert an integral index in [0-27] to a character in [a-z] or"
 #" whitespace"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   index, an integer"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 20 #";;   ch, a character"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;   index is in [0,27]"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;   ch is in [a-z], i.e., a lower-case Roman character, or whitespa"
 #"ce"
) 0 0 24 29 1 #"\n"
0 0 17 3 60
#";;    with 0 corresponding to #\\a, 25 corresponding to #\\z, "
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;   and 26 corresponding to space, and 27 corresponding to newline"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 11 #"index->char"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (("
0 0 14 3 7 #"a-index"
0 0 24 3 2 #" ("
0 0 14 3 13 #"char->integer"
0 0 24 3 1 #" "
0 0 21 3 3 #"#\\a"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 5 #"index"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"     ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 1 #"="
0 0 24 3 1 #" "
0 0 14 3 5 #"index"
0 0 24 3 1 #" "
0 0 21 3 2 #"26"
0 0 24 3 2 #") "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 21 3 7 #"#\\space"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 1 #"="
0 0 24 3 1 #" "
0 0 14 3 5 #"index"
0 0 24 3 1 #" "
0 0 21 3 2 #"27"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 21 3 9 #"#\\newline"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 13 #"integer->char"
0 0 24 3 2 #" ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 5 #"index"
0 0 24 3 1 #" "
0 0 14 3 7 #"a-index"
0 0 24 3 7 #"))]))))"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"    "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;   count-transitions!"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;   Count the number of times one character is followed by another "
 #"in a file"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;   filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   counts, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";;   [Nothing. Called for side-effect.]"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;   filename refers to a valid text file"
0 0 24 29 1 #"\n"
0 0 17 3 36 #";;   counts is a vector of length 28"
0 0 24 29 1 #"\n"
0 0 17 3 50 #";;   Each entry in counts is a vector of length 28"
0 0 24 29 1 #"\n"
0 0 17 3 55 #";;   Each entry within those member vectors is a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 66
#";;   (get-count counts prev next) is incremented for each adjacent"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;     character pair (prev next) in the file pointed to by filename"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";;     "
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 18 #"count-transitions!"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 8 #"filename"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (("
0 0 14 3 6 #"inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 8 #"filename"
0 0 24 3 3 #")))"
0 0 17 3 23 #"; Open file for reading"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (("
0 0 14 3 7 #"prev-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 6 #"inport"
0 0 24 3 3 #")) "
0 0 17 3 25 #"; Read first char as prev"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 7 #"next-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 6 #"inport"
0 0 24 3 3 #")))"
0 0 17 3 26 #"; Read second char as next"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #" (("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 7 #"next-ch"
0 0 24 3 16 #")               "
0 0 17 3 11 #"; All done?"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 16 #"close-input-port"
0 0 24 3 1 #" "
0 0 14 3 6 #"inport"
0 0 24 3 12 #"))          "
0 0 17 3 12 #"; Close port"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 52 #";counts)                             ; Return counts"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 16 #"increment-count!"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 12 #"            "
0 0 17 3 23 #"; increment counts with"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 7 #"prev-ch"
0 0 24 3 2 #") "
0 0 17 3 26 #"; previous character index"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 7 #"next-ch"
0 0 24 3 2 #"))"
0 0 17 3 30 #"; current/next character index"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 4 #"loop"
0 0 24 3 1 #" "
0 0 14 3 7 #"next-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 6 #"inport"
0 0 24 3 9 #")))))))) "
0 0 17 3 29 #"; loop, reading new next char"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   transpose-counts"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 52 #";;   Produce a count structure with reversed indices"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   counts, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 5 #";;   "
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   tr-counts, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 47 #";;   Let counts be a vector of length num-chars"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;   Each entry in counts is a vector of length num-chars"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   (get-count counts i j) = (get-count tr-counts j i) "
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;     for all 0 <= i,j < num-chars"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 16 #"transpose-counts"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 6 #"counts"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 3 #" (["
0 0 14 3 3 #"len"
0 0 24 3 2 #" ("
0 0 14 3 13 #"vector-length"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 7 #"indices"
0 0 24 3 2 #" ("
0 0 14 3 4 #"iota"
0 0 24 3 1 #" "
0 0 14 3 3 #"len"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 9 #"counts-tr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"create-counts"
0 0 24 3 1 #" "
0 0 14 3 3 #"len"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 8 #"for-each"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 7 #"index-1"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (["
0 0 14 3 5 #"slice"
0 0 24 3 2 #" ("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 9 #"counts-tr"
0 0 24 3 1 #" "
0 0 14 3 7 #"index-1"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 8 #"for-each"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 7 #"index-2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 11 #"vector-set!"
0 0 24 3 1 #" "
0 0 14 3 5 #"slice"
0 0 24 3 1 #" "
0 0 14 3 7 #"index-2"
0 0 24 3 2 #" ("
0 0 14 3 9 #"get-count"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 1 #" "
0 0 14 3 7 #"index-2"
0 0 24 3 1 #" "
0 0 14 3 7 #"index-1"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 14 3 7 #"indices"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"       "
0 0 14 3 7 #"indices"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 14 3 9 #"counts-tr"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 20 #";;   marginal-counts"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 79
(
 #";;   Produce a vector of all the counts in the first index of a coun"
 #"t structure"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   counts, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;   marginal, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 47 #";;   Let counts be a vector of length num-chars"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;   Each entry in counts is a vector of length num-chars"
0 0 24 29 1 #"\n"
0 0 17 3 62
#";;   Each entry within those member vectors is a number, i.e.,"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;     (number? (vector-ref (vector-ref counts i) j)) "
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;        for 0 <= i,j < num-chars"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 79
(
 #";;   Each entry in marginal is the sum of the corresponding \"column"
 #"\" in counts:"
) 0 0 24 29 1 #"\n"
0 0 17 3 56 #";;     marg[index2] = sum_{index1} counts[index1,index2]"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 15 #"marginal-counts"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 6 #"counts"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 2 #" ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 2 #") "
0 0 14 3 10 #"vector-sum"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   normalize-marginal-counts!"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   Normalize a non-negative count vector as a marginal probabilitu"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";;   counts-marg, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";;   [Nothing. Called for side effect.]"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 44 #";;   Every entry in counts-marg is a number:"
0 0 24 29 1 #"\n"
0 0 17 3 44 #";;     (number? (vector-ref counts-marg i)) "
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;       for 0 <= i < (vector-length counts-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;   The sum of the vector is one:"
0 0 24 29 1 #"\n"
0 0 17 3 36 #";;     (vector-sum counts-marg) == 1"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 26 #"normalize-marginal-counts!"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 11 #"counts-marg"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (["
0 0 14 3 5 #"total"
0 0 24 3 2 #" ("
0 0 14 3 10 #"vector-sum"
0 0 24 3 1 #" "
0 0 14 3 11 #"counts-marg"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 1 #" "
0 0 14 3 11 #"counts-marg"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 3 #"num"
0 0 24 3 3 #") ("
0 0 14 3 1 #"/"
0 0 24 3 1 #" "
0 0 14 3 3 #"num"
0 0 24 3 1 #" "
0 0 14 3 5 #"total"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 4 #"void"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   counts->list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;   Transform vector of vectors into vector of lists"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   counts, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";;   count-list, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 37 #";;   Each entry in counts is a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;   Each entry in counts-list is a list:"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;     (list? (vector-ref counts-list i)) for 0 <= i < (vector-lengt"
 #"h counts)"
) 0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";;   Each list in counts-list corresponds to the original vector in "
 #"counts:"
) 0 0 24 29 1 #"\n"
0 0 17 3 46 #";;     (length (vector-ref counts-list i)) == "
0 0 24 29 1 #"\n"
0 0 17 3 52 #";;       (vector-length (vector-ref counts-list i)) "
0 0 24 29 1 #"\n"
0 0 17 3 44 #";;       for 0 <= i < (vector-length counts)"
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;     (list-ref (vector-ref counts-list i) j) =="
0 0 24 29 1 #"\n"
0 0 17 3 50 #";;       (vector-ref (vector-ref counts-list i) j)"
0 0 24 29 1 #"\n"
0 0 17 3 48 #";;       for 0 <= i < (vector-length counts) and"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";;           0 <= j < (vector-length (vector-ref counts i))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 12 #"counts->list"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 6 #"counts"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 12 #"list->vector"
0 0 24 3 2 #" ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 12 #"vector->list"
0 0 24 3 2 #" ("
0 0 14 3 12 #"vector->list"
0 0 24 3 1 #" "
0 0 14 3 6 #"counts"
0 0 24 3 5 #")))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 14 #";;   logsumexp"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 62
#";;   Calculate a numerically stable sum of values in log space"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   lst, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   logsum, a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   vals is non-empty: (< 0 (length vals))"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   Every element of vals is a number: (number? (list-ref vals i)) "
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;      for 0 <= i < (length vals)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 60
#";;   Mathematically, logsum == (log (apply + (map exp lst)))"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;     However, lst's largest value is subtracted from every element"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";;       prior to exponentiation for numerical stability with inexac"
 #"t"
) 0 0 24 29 1 #"\n"
0 0 17 3 61
#";;       values. lsts's largest value is added to the result."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 9 #"logsumexp"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 3 #"lst"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (("
0 0 14 3 2 #"mx"
0 0 24 3 2 #" ("
0 0 14 3 5 #"apply"
0 0 24 3 1 #" "
0 0 14 3 3 #"max"
0 0 24 3 1 #" "
0 0 14 3 3 #"lst"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 2 #"mx"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 3 #"log"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 5 #"apply"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 3 #"val"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 3 #"exp"
0 0 24 3 2 #" ("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 3 #"val"
0 0 24 3 1 #" "
0 0 14 3 2 #"mx"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"      "
0 0 14 3 3 #"lst"
0 0 24 3 7 #")))))))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"     "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";;   evidence-exact"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   Calculate exact marginal evidence for observed data"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   corrupt-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   typo-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-marg, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   ev, a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   corrupt-filename points to a valid, readable file"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;   typo-cond, lang-cond, and lang-marge have the same length:"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;     (= (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;   The elements of typo-cond and lang-cond are all vectors the sam"
 #"e "
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";;     length as lang-marg:"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;       (= (vector-ref typo-cond i) (vector-length lang-marg)) and"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;       (= (vector-ref lang-cond i) (vector-length lang-marg))"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;         for all 0 <= i < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   The elements of vectors in typo-cond and lang-cond are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 60
#";;     (number? (vector-ref (vector-ref typo-cond i) j)) and"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;     (number? (vector-ref (vector-ref lang-cond i) j)) "
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;        for 0 <= i,j  < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   The elements of lang-marg are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;     (number? (vector-ref lang-marg i))"
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;        for 0 <= i  < (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;   ev represents P(o|D,L,I) = \\sum_{c} P(o,c|D,L,I)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Practica"
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;   Because the evidence is calculated exactly if the counts are ex"
 #"act, "
) 0 0 24 29 1 #"\n"
0 0 17 3 44 #";;     this procedure is prohibitively slow."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   Loosely inspired by Equation (15.7) in AIMA (3/e)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 14 #"evidence-exact"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 3 #" (["
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #" ("
0 0 14 3 13 #"vector-length"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 12 #"lang-indices"
0 0 24 3 2 #" ("
0 0 14 3 4 #"iota"
0 0 24 3 1 #" "
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 69
(
 #"; List form for (tranposed) typist model so that we have a vector of"
 #" "
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 68
#"; lists, where the first (vector) index corresponds to the observed "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 71
(
 #"; character, and the second (list) index corresponds to the hidden t"
 #"rue"
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 11 #"; character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 3 2 #" ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 72
(
 #"; List form for (transposed) language model so that we have a vector"
 #" of "
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 71
(
 #"; lists, where the first (vector) index corresponds to the next/curr"
 #"ent"
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 60
#"; character, and the second (list) index corresponds to the "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 20 #"; previous character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 16 #"lang-cond-tr-lst"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 3 2 #" ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 67
(
 #"; List form for marginal (\"prior\") probability for a true characte"
 #"r"
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 13 #"lang-marg-lst"
0 0 24 3 2 #" ("
0 0 14 3 12 #"vector->list"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 34 #"; Port for reading characters from"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 30 #"; First character in the file "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 20 #"; Procedure: message"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 62
#"; Purpose: Calculate the marginal likelihood function M(C'|o')"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 28 #"; Parameter: ch, a character"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 33 #";            prev-message, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 24 #"; Produces:  msg, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 71
(
 #"; Preconditions: ch is a valid input to char->index or (eof-object? "
 #"ch)"
) 0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 69
(
 #";                prev-message is M(C|o), previous marginal likelihoo"
 #"d"
) 0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 51 #"; Postconditions: msg is a list of length num-chars"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 6 #"letrec"
0 0 24 3 3 #" (["
0 0 14 3 7 #"message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"ch"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"   [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #") "
0 0 17 3 30 #"; Out of observable characters"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 17 3 31 #"; Final processing: sum message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 5 #"apply"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 3 #")] "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 2 #" ("
0 0 17 3 49 #"; Number representing index of observed character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #" ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 28 #"; List representing P(o'|C')"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-slice"
0 0 24 3 2 #" ("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 12 #"next-message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 52 #"; Message is a list over current (true) character C'"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #") "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 8 #"list-ref"
0 0 24 3 1 #" "
0 0 14 3 10 #"typo-slice"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #") "
0 0 17 3 12 #"; P(o'|C') x"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 17 3 45 #"; Marginal over prior unbserved char C adding"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 17 3 42 #";     P(C'|C) x M(C|o) for all values of C"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 5 #"apply"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 1 #"*"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"lang-cond-tr-lst"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 12 #"prev-message"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 14 3 12 #"lang-indices"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 7 #"message"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"       "
0 0 14 3 12 #"next-message"
0 0 24 3 7 #"))]))])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #" [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #") "
0 0 17 3 39 #"; No observable characters (empty file)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 21 3 1 #"1"
0 0 24 3 2 #"] "
0 0 17 3 18 #"; Likelihood is 1."
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 7 #"message"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 14 3 13 #"lang-marg-lst"
0 0 24 3 7 #")])))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   log-evidence"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 58
#";;   Calculate inexact marginal evidence for observed data"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   corrupt-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   typo-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-marg, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";;   ev, a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   corrupt-filename points to a valid, readable file"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;   typo-cond, lang-cond, and lang-marge have the same length:"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;     (= (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;   The elements of typo-cond and lang-cond are all vectors the sam"
 #"e "
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";;     length as lang-marg:"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;       (= (vector-ref typo-cond i) (vector-length lang-marg)) and"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;       (= (vector-ref lang-cond i) (vector-length lang-marg))"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;         for all 0 <= i < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   The elements of vectors in typo-cond and lang-cond are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 60
#";;     (number? (vector-ref (vector-ref typo-cond i) j)) and"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;     (number? (vector-ref (vector-ref lang-cond i) j)) "
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;        for 0 <= i,j  < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   The elements of lang-marg are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;     (number? (vector-ref lang-marg i))"
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;        for 0 <= i  < (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;   ev represents P(o|D,L,I) = \\sum_{c} P(o,c|D,L,I)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   Loosely Inspired by Equation (15.7) in AIMA (3/e)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 12 #"log-evidence"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 3 #" (["
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #" ("
0 0 14 3 13 #"vector-length"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 12 #"lang-indices"
0 0 24 3 2 #" ("
0 0 14 3 4 #"iota"
0 0 24 3 1 #" "
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 68
#"; List form for (tranposed) typist model so that we have a vector of"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 68
#"; lists, where the first (vector) index corresponds to the observed "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 67
#"; character, and the second (list) index corresponds to the hidden "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 16 #"; true character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 2 #" ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 3 #"l-s"
0 0 24 3 1 #" "
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 72
(
 #"; List form for (transposed) language model so that we have a vector"
 #" of "
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 71
(
 #"; lists, where the first (vector) index corresponds to the next/curr"
 #"ent"
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 60
#"; character, and the second (list) index corresponds to the "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 20 #"; previous character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 16 #"lang-cond-tr-lst"
0 0 24 3 2 #" ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 3 #"l-s"
0 0 24 3 1 #" "
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 67
(
 #"; List form for marginal (\"prior\") probability for a true characte"
 #"r"
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 13 #"lang-marg-lst"
0 0 24 3 2 #" ("
0 0 14 3 12 #"vector->list"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 34 #"; Port for reading characters from"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 30 #"; First character in the file "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 20 #"; Procedure: message"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 62
#"; Purpose: Calculate the marginal likelihood function M(C'|o')"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 28 #"; Parameter: ch, a character"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 33 #";            prev-message, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 24 #"; Produces:  msg, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 71
(
 #"; Preconditions: ch is a valid input to char->index or (eof-object? "
 #"ch)"
) 0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 69
(
 #";                prev-message is M(C|o), previous marginal likelihoo"
 #"d"
) 0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 51 #"; Postconditions: msg is a list of length num-chars"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 6 #"letrec"
0 0 24 3 3 #" (["
0 0 14 3 7 #"message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"ch"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"   [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #") "
0 0 17 3 30 #"; Out of observable characters"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 17 3 31 #"; Final processing: sum message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 9 #"logsumexp"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 3 #")] "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 2 #" ("
0 0 17 3 49 #"; Number representing index of observed character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #" ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 28 #"; List representing P(o'|C')"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-slice"
0 0 24 3 2 #" ("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 12 #"next-message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 52 #"; Message is a list over current (true) character C'"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #") "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 17 3 29 #"; product is sum in log space"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 8 #"list-ref"
0 0 24 3 1 #" "
0 0 14 3 10 #"typo-slice"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #") "
0 0 17 3 12 #"; P(o'|C') x"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 17 3 45 #"; Marginal over prior unbserved char C adding"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 17 3 42 #";     P(C'|C) x M(C|o) for all values of C"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 9 #"logsumexp"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 2 #"  "
0 0 17 3 29 #"; product is sum in log space"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"lang-cond-tr-lst"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 12 #"prev-message"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 14 3 12 #"lang-indices"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 7 #"message"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"       "
0 0 14 3 12 #"next-message"
0 0 24 3 7 #"))]))])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #" [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #") "
0 0 17 3 39 #"; No observable characters (empty file)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 21 3 1 #"0"
0 0 24 3 2 #"] "
0 0 17 3 23 #"; Likelihood is log(1)."
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 7 #"message"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 1 #" "
0 0 14 3 13 #"lang-marg-lst"
0 0 24 3 8 #"))])))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";;   most-likely-sequence"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;   Calculate a maximum prob. sequence of characters to explain obs"
 #"ervations"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   corrupt-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   typo-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-cond, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";;   lang-marg, a vector"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   mls, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   corrupt-filename points to a valid, readable file"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;   typo-cond, lang-cond, and lang-marge have the same length:"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;     (= (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";;        (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;   The elements of typo-cond and lang-cond are all vectors the sam"
 #"e "
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";;     length as lang-marg:"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;       (= (vector-ref typo-cond i) (vector-length lang-marg)) and"
0 0 24 29 1 #"\n"
0 0 17 3 63
#";;       (= (vector-ref lang-cond i) (vector-length lang-marg))"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";;         for all 0 <= i < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";;   The elements of vectors in typo-cond and lang-cond are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 60
#";;     (number? (vector-ref (vector-ref typo-cond i) j)) and"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;     (number? (vector-ref (vector-ref lang-cond i) j)) "
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;        for 0 <= i,j  < (vector-length typo-cond)"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;   The elements of lang-marg are numbers:"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;     (number? (vector-ref lang-marg i))"
0 0 24 29 1 #"\n"
0 0 17 3 49 #";;        for 0 <= i  < (vector-length lang-marg)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";;   mls has the same number of characters as the file pointed to by"
 #" "
) 0 0 24 29 1 #"\n"
0 0 17 3 23 #";;     corrupt-filename"
0 0 24 29 1 #"\n"
0 0 17 3 80
(
 #";;   mls contains characters: (char? (list-ref mls i)) for 0 <= i < "
 #"(length mls)"
) 0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   mls corresponds to the sequence argmax P(c|o,D,L,I)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; Props"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";;   Loosely inspired by Equation 15.11 of AIMA (3/e)."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 20 #"most-likely-sequence"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 3 #" (["
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #" ("
0 0 14 3 13 #"vector-length"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 12 #"lang-indices"
0 0 24 3 2 #" ("
0 0 14 3 4 #"iota"
0 0 24 3 1 #" "
0 0 14 3 9 #"num-chars"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 69
(
 #"; List form for (tranposed) typist model so that we have a vector of"
 #" "
) 0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 68
#"; lists, where the first (vector) index corresponds to the observed "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 64
#"; character, and the second (list) index corresponds to the true"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 52 #"; character. Results are transformed into log space "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 46 #"; (so these are log conditional probabilities)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 2 #" ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 16 #"transpose-counts"
0 0 24 3 1 #" "
0 0 14 3 9 #"typo-cond"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 3 #"lst"
0 0 24 3 3 #") ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 1 #" "
0 0 14 3 3 #"lst"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 66
#"; List form for language model so that we have a vector of lists, "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 61
#"; where the first (vector) index corresponds to the previous "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 60
#"; character, and the second (list) index corresponds to the "
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 65
#"; next/current character. Results are transformed into log space "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 46 #"; (so these are log conditional probabilities)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 13 #"lang-cond-lst"
0 0 24 3 2 #" ("
0 0 14 3 11 #"vector-map!"
0 0 24 3 2 #" ("
0 0 14 3 12 #"counts->list"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-cond"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 3 #"lst"
0 0 24 3 3 #") ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 1 #" "
0 0 14 3 3 #"lst"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 67
(
 #"; List form for marginal (\"prior\") probability for a true characte"
 #"r"
) 0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 41 #"; Results are transformed into log space "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 43 #"; (so these are log marginal probabilities)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 13 #"lang-marg-lst"
0 0 24 3 2 #" ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"log"
0 0 24 3 2 #" ("
0 0 14 3 12 #"vector->list"
0 0 24 3 1 #" "
0 0 14 3 9 #"lang-marg"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 34 #"; Port for reading characters from"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 16 #"corrupt-filename"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 17 3 61
#"; First character in the file (for pre-recursion calculation)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 6 #"letrec"
0 0 24 3 2 #" ("
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 20 #"; Procedure: message"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 60
#"; Purpose: Calculate the most likely paths at each time step"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 29 #"; Parameters: ch, a character"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 34 #";             prev-message, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 33 #";             prev-labels, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 27 #"; Produces:  labels, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 71
(
 #"; Preconditions: ch is a valid input to char->index or (eof-object? "
 #"ch)"
) 0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 59
#";                prev-message is a list of length num-chars"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 67
#";                prev-labels is a list of lists of length num-chars"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 65
#"; Postconditions: labels is a list of characters representing the"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 49 #";                 most likely sequence prediction"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ["
0 0 14 3 7 #"message"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"ch"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 1 #" "
0 0 14 3 11 #"prev-labels"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 54 #";(display \"Message: \") (display prev-message)(newline)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 51 #";(display \"Table: \") (display prev-labels)(newline)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"   [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #") "
0 0 17 3 31 #"; Out of observable characters?"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 17 3 58
#"; Finish up: run the prediction loop using the label table"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (["
0 0 14 3 5 #"index"
0 0 24 3 2 #" ("
0 0 14 3 6 #"argmax"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 7 #"predict"
0 0 24 3 1 #" "
0 0 14 3 5 #"index"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ("
0 0 14 3 4 #"list"
0 0 24 3 2 #" ("
0 0 14 3 11 #"index->char"
0 0 24 3 1 #" "
0 0 14 3 5 #"index"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"       "
0 0 14 3 11 #"prev-labels"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 17 3 58
#";(display (string-append \"ch: \" (list->string (list ch))))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"    "
0 0 17 3 10 #";(newline)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 15 3 4 #"let*"
0 0 24 3 2 #" ("
0 0 17 3 49 #"; Number representing index of observed character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #" ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 2 #"ch"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 28 #"; List representing P(o'|C')"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 10 #"typo-slice"
0 0 24 3 2 #" ("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 10 #"typo-index"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 53 #"; List over C' (current true character) of lists over"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 29 #"; C (previous true character)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 9 #"msg-pairs"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #") "
0 0 17 3 16 #"; mapped over C'"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"     "
0 0 17 3 47 #"; Calculate value of transition, using products"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"     "
0 0 17 3 33 #";     P(o'|C') x P(C'|C) x M(C|o)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"     "
0 0 17 3 24 #"; for all values of C,C'"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 3 #"l-s"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 2 #" ("
0 0 14 3 8 #"list-ref"
0 0 24 3 1 #" "
0 0 14 3 10 #"typo-slice"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 17 3 16 #"; mapped over C "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 17 3 31 #"; Product is sum in log space, "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 13 #"lang-cond-lst"
0 0 24 3 1 #" "
0 0 14 3 10 #"lang-index"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #" "
0 0 14 3 12 #"prev-message"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"       "
0 0 14 3 12 #"lang-indices"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 48 #"; List of max and argmax value pairs for each C'"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ["
0 0 14 3 8 #"msg-vals"
0 0 24 3 2 #" ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 7 #"arg+max"
0 0 24 3 1 #" "
0 0 14 3 9 #"msg-pairs"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"      "
0 0 17 3 53 #"; With all that heavy lifting done, continue the loop"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 7 #"message"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 8 #"msg-vals"
0 0 24 3 2 #") "
0 0 17 3 20 #"; Extract max values"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ("
0 0 14 3 4 #"cons"
0 0 24 3 2 #" ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 8 #"msg-vals"
0 0 24 3 2 #") "
0 0 17 3 21 #"; Add labels to table"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"     "
0 0 14 3 11 #"prev-labels"
0 0 24 3 7 #")))]))]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 20 #"; Procedure: predict"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 60
#"; Purpose: Read back the most likely paths at each time step"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 36 #"; Parameters: prev-index, an integer"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 33 #";             predictions, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 33 #";             label-table, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 27 #"; Produces:  labels, a list"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 58
#"; Preconditions: prev-index is an integer in [0,num-chars]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 52 #";                predictions is a list of characters"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 68
#";                label-table is a list of lists of character indices"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 65
#"; Postconditions: labels is a list of characters representing the"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 49 #";                 most likely sequence prediction"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 8 #"       ["
0 0 14 3 7 #"predict"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 10 #"prev-index"
0 0 24 3 1 #" "
0 0 14 3 11 #"predictions"
0 0 24 3 1 #" "
0 0 14 3 11 #"label-table"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 11 #"label-table"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"      "
0 0 14 3 11 #"predictions"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 15 3 4 #"let*"
0 0 24 3 3 #" (["
0 0 14 3 6 #"labels"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 11 #"label-table"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ["
0 0 14 3 10 #"next-index"
0 0 24 3 2 #" ("
0 0 14 3 8 #"list-ref"
0 0 24 3 1 #" "
0 0 14 3 6 #"labels"
0 0 24 3 1 #" "
0 0 14 3 10 #"prev-index"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ["
0 0 14 3 10 #"prediction"
0 0 24 3 2 #" ("
0 0 14 3 11 #"index->char"
0 0 24 3 1 #" "
0 0 14 3 10 #"next-index"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 7 #"predict"
0 0 24 3 1 #" "
0 0 14 3 10 #"next-index"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 14 3 10 #"prediction"
0 0 24 3 1 #" "
0 0 14 3 11 #"predictions"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 11 #"label-table"
0 0 24 3 7 #")))))])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 17 3 53 #";; Finally, the body of function most-likely-sequence"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #" [("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 3 2 #") "
0 0 17 3 39 #"; No observable characters (empty file)"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 14 3 4 #"null"
0 0 24 3 2 #"] "
0 0 17 3 26 #"; Prediction is empty list"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 41 #"; Start the recursive message calculation"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 7 #"message"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 25 #"; Read the next character"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"corrupt-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 31 #"; Calculate the initial message"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #"  "
0 0 17 3 36 #"; P(C) x P(o|C) over all values of C"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 4 #"   ("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 17 3 29 #"; Product is sum in log space"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 14 3 13 #"lang-marg-lst"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 15 #"get-count-slice"
0 0 24 3 1 #" "
0 0 14 3 16 #"typo-cond-tr-lst"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ("
0 0 14 3 11 #"char->index"
0 0 24 3 1 #" "
0 0 14 3 8 #"first-ch"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 17 3 50 #"; Initial conditional previous state list is empty"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"   "
0 0 14 3 4 #"null"
0 0 24 3 7 #")])))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   count-errors-file"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";;   Count the number of discrepancies betwen two files of the same "
 #"length"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   correct-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 29 #";;   other-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   errors, a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";;   correct-filename points to a valid, readable text file"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";;   other-filename points to a valid, readable text file"
0 0 24 29 1 #"\n"
0 0 17 3 36 #";;   Both files have the same length"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   errors >= 0"
0 0 24 29 1 #"\n"
0 0 17 3 83
(
 #";;   errors is the number of characters that differ between the file"
 #"s pointed to by"
) 0 0 24 29 1 #"\n"
0 0 17 3 43 #";;     correct-filename and other-filename."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 17 #"count-errors-file"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 16 #"correct-filename"
0 0 24 3 1 #" "
0 0 14 3 14 #"other-filename"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 2 #" ("
0 0 17 3 24 #"; Open files for reading"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 14 #"correct-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 16 #"correct-filename"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 12 #"other-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 14 #"other-filename"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (["
0 0 14 3 5 #"total"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 10 #"correct-ch"
0 0 24 3 3 #"  ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"correct-inport"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 8 #"other-ch"
0 0 24 3 2 #" ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 12 #"other-inport"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 2 #") "
0 0 17 3 29 #"; Both finished, report total"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 8 #"other-ch"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 14 3 5 #"total"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 2 #"or"
0 0 24 3 2 #" ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 2 #") "
0 0 17 3 28 #"; One finished, but not both"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 8 #"other-ch"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 29 #"\"Files have different length\""
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 4 #"loop"
0 0 24 3 2 #" ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 5 #"total"
0 0 24 3 2 #" ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 1 #" "
0 0 14 3 8 #"other-ch"
0 0 24 3 2 #") "
0 0 21 3 1 #"0"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"correct-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 12 #"other-inport"
0 0 24 3 8 #"))])))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   count-errors-list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 81
(
 #";;   Count the number of discrepancies between a file and list of th"
 #"e same length"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 31 #";;   correct-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   char-list, a list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";;   errors, a number"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";;   correct-filename points to a valid, readable text file"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";;   char-list contains only characters: (char? (list-ref char-list "
 #"i)) "
) 0 0 24 29 1 #"\n"
0 0 17 3 38 #";;     for 0 <= i < (length char-list)"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;   The file pointed to by correct-filename has the same length as "
 #"char-list"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";;   errors >= 0"
0 0 24 29 1 #"\n"
0 0 17 3 82
(
 #";;   errors is the number of characters that differ between the file"
 #" pointed to by"
) 0 0 24 29 1 #"\n"
0 0 17 3 68
#";;     correct-filename and the corresponding character in char-list"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 17 #"count-errors-list"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 16 #"correct-filename"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 2 #" ("
0 0 17 3 23 #"; Open file for reading"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 14 #"correct-inport"
0 0 24 3 2 #" ("
0 0 14 3 15 #"open-input-file"
0 0 24 3 1 #" "
0 0 14 3 16 #"correct-filename"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (["
0 0 14 3 5 #"total"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 10 #"correct-ch"
0 0 24 3 3 #"  ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"correct-inport"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 9 #"char-list"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 2 #"])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 2 #") "
0 0 17 3 29 #"; Both finished, report total"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 6 #"     ("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 14 3 5 #"total"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"       [("
0 0 14 3 2 #"or"
0 0 24 3 2 #" ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 2 #") "
0 0 17 3 28 #"; One finished, but not both"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 5 #"    ("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 38 #"\"File and list have different lengths\""
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ["
0 0 14 3 4 #"else"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 14 3 4 #"loop"
0 0 24 3 2 #" ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 5 #"total"
0 0 24 3 2 #" ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 1 #" "
0 0 14 3 10 #"correct-ch"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 3 #")) "
0 0 21 3 1 #"0"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 9 #"read-char"
0 0 24 3 1 #" "
0 0 14 3 14 #"correct-inport"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 7 #"      ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 8 #"))])))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; Procedure"
0 0 24 29 1 #"\n"
0 0 17 3 15 #";;   list->file"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 10 #";; Purpose"
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;   Write a list of characters to a file"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; Parameters"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";;   char-list, a list"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";;   out-filename, a string"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; Produces"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";;   [Nothing. Called for side-effect.]"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; Preconditions"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;   out-filename points to a valid, writeable filename."
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";;   char-list contains only characters: (char? (list-ref char-list "
 #"i)) "
) 0 0 24 29 1 #"\n"
0 0 17 3 38 #";;     for 0 <= i < (length char-list)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; Postconditions"
0 0 24 29 1 #"\n"
0 0 17 3 81
(
 #";;   The characters in char-list are written to a file pointed to by"
 #" out-filename"
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";;     in their list order."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 10 #"list->file"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 9 #"char-list"
0 0 24 3 1 #" "
0 0 14 3 12 #"out-filename"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 3 #"let"
0 0 24 3 2 #" ("
0 0 17 3 23 #"; Open file for writing"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ["
0 0 14 3 7 #"outport"
0 0 24 3 2 #" ("
0 0 14 3 16 #"open-output-file"
0 0 24 3 1 #" "
0 0 14 3 12 #"out-filename"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" (["
0 0 14 3 5 #"chars"
0 0 24 3 1 #" "
0 0 14 3 9 #"char-list"
0 0 24 3 2 #"])"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 1 #"("
0 0 15 3 4 #"cond"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #" [("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 5 #"chars"
0 0 24 3 2 #") "
0 0 17 3 25 #"; No more chars to write?"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 17 #"close-output-port"
0 0 24 3 1 #" "
0 0 14 3 7 #"outport"
0 0 24 3 3 #")] "
0 0 17 3 15 #"; Close up shop"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 2 #" ["
0 0 14 3 4 #"else"
0 0 24 3 1 #" "
0 0 17 3 11 #"; Otherwise"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 10 #"write-char"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 5 #"chars"
0 0 24 3 2 #") "
0 0 14 3 7 #"outport"
0 0 24 3 2 #") "
0 0 17 3 20 #"; Write char to file"
0 0 24 29 1 #"\n"
0 1 24 65 1 #"\t"
0 0 24 3 3 #"  ("
0 0 14 3 4 #"loop"
0 0 24 3 2 #" ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 5 #"chars"
0 0 24 3 9 #"))]))))) "
0 0 17 3 32 #"; Continue loop on rest of chars"
0 0 24 29 1 #"\n"
0           0
